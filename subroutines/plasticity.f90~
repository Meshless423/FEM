!******************************************************
!
! This file contains subroutines used for plasticity
!
!******************************************************


! **********************************************************************
!   Subroutine invar - Owen p. 239  
!   This subroutine evaluates the stress invariants and the current value of
!       the yield function
! ***********************************************************************

subroutine invar(lprop,stemp)

use variables
implicit none

double precision, dimension(4) :: stemp
double precision :: varj1
integer :: lprop

! write(6,*) 'stemp dans invar',stemp
! stop

! First invariant I1=Tr(sigma)
smean=(stemp(1)+stemp(2)+stemp(4))/3.d0 

!Compute deviatoric stresses according to (7.7): s=sigma -(1/3)*I1
devia(1)=stemp(1)-smean         ! sigma_xx
devia(2)=stemp(2)-smean         ! sigma_yy
devia(3)=stemp(3)               ! sigma_xy
devia(4)=stemp(4)-smean         ! sigma_ZZ


!On vérifie qu'il n'y a pas d'incohérences dans le tenseur déviatorique
!We check there are no inconstitencies with the deviatoric tensor, i.e. if J1=0 (First deviatoric stress invariant J1')
	varj1=devia(1)+devia(2)+devia(4)

! 	write(6,*) "smean, devia(1),devia(2),devia(3),devia(4)="
! 	write(6,*) smean,devia(1),devia(2),devia(3),devia(4)
	!stop

	if (abs(varj1) > 1.d-8) then
    	write(6,*) 'Error in the deviatoric stress tensor: J1 ≠ 0 =', varj1
    	stop
	end if
! End test

!Calculate second deviatoric stress invariant J2'
varj2=devia(3)*devia(3)+0.5d0*(devia(1)*devia(1) + devia(2)*devia(2) + devia(4)*devia(4))
! write(6,*) "varj2=",varj2

!Calculate third deviatoric stress invariant J3'
varj3=devia(4)*(devia(4)*devia(4)-varj2)

!Compute √(J2')
steff=dsqrt(varj2)
! write(6,*) "steff=",steff

! Evaluate sin(3theta)
if (steff == 0.d0) then
	sint3=0.d0  
else
	sint3=-3.d0*root3*varj3/(2.d0*varj2*steff)

	if(sint3 > 1.d0) then
		sint3=1.d0
	end if
end if

! Compute theta
if(sint3 < -1.d0) then
    sint3=-1.d0
end if

if(sint3 > 1.d0) then
    sint3=1.d0
end if

theta=dasin(sint3)/3.d0


! Evaluate yield function according to the criterion
select case(ncrit)
    case(1)     !ncrit=1: Tresca yield criterion
        yield=2.d0*dcos(theta)*steff
        return
    case(2)     !ncrit=2: Von Mises
        yield=root3*steff
!         print *,"yield=",yield
        return
    case(3)     !ncrit=3: Mohr-Coulomb
        phira=props(lprop,7)*degres
        snphi=dsin(phira)
        yield=smean*snphi+steff*(dcos(theta)-dsin(theta)*snphi/root3)
        return
    case(4)     !ncrit=4: Drucker-Prager
        phira=props(lprop,7)*degres
        snphi=dsin(phira)
        yield=6.d0*smean*snphi/(root3*(3.d0-snphi))+steff
        return
    case(5)     !ncrit=5: Cam-Clay
        yield=(3.d0*varj2/(smean*csl*csl))+smean

!         eeta=root3*steff/smean
        !pccrnt=smean*((csl**2+eeta**2)/csl**2)
        return
    !Change  44
!    case(6)     !ncrit=6: Alonso's model BBM
!        q=1.732050808*steff
!        yield=smean+(q**2/(csl**2*(smean+ck*suctot)))
!        return
    !End of change 44
end select


end

!********************************************************************
!   Subroutine yieldf - Owen p.241
!   This subroutine evaluates the flow vector a defined in (7.74)
!********************************************************************

subroutine yieldf(lprop)

use variables

implicit none

!double precision, dimension(4)  :: veca1, veca2, veca3, veca4
!double precision :: root3=1.73205080757
!double precision :: frict, snphi, tanth, tant3, sinth, costh, cost3
!double precision :: abthe, cons1, cons2, cons3, plumi, gseta

integer :: istr1, lprop


! write(6,*) steff
! stop

if(steff == 0.d0) then
    return
end if


frict=props(lprop,7)
snphi=dsin(frict*degres) ! ?
tanth=dtan(theta)
tant3=dtan(3.d0*theta)
sinth=dsin(theta)
costh=dcos(theta)
cost3=dcos(3.d0*theta)
!root3=1.73205080757

! Calculate vector a1

veca1(1)=1.d0
veca1(2)=1.d0
veca1(3)=0.d0
veca1(4)=1.d0

! Calculate vector a2

do istr1=1,nstr1
    veca2(istr1)=devia(istr1)/(2.d0*steff)
end do

veca2(3)=devia(3)/steff

! Calculate vector a3

veca3(1)=devia(2)*devia(4)+varj2/3.d0
veca3(2)=devia(1)*devia(4)+varj2/3.d0
veca3(3)=-2.d0*devia(3)*devia(4)
veca3(4)=devia(1)*devia(2)-devia(3)*devia(3)+varj2/3.d0

select case(ncrit)
    case(1)     ! ncrit=1: Tresca
        cons1=0.d0
        abthe=dabs(theta*radian)
        if(abthe >= 29.d0) then
            cons2=root3
            cons3=0.d0
        end if
        
        if(abthe < 29.d0) then
            cons2=2.d0*(costh+sinth*tant3)
            cons3=root3*sinth/(varj2*cost3)
        end if
    
    case(2)     ! ncrit=2: Von Mises
        cons1=0.d0
        cons2=root3
        cons3=0.d0
        
    case(3)     ! ncrit=3: Mohr-Coulomb
        cons1=dsin(frict*degres)/3.d0
        abthe=dabs(theta*radian)
        
        if(abthe >= 29.d0) then
            cons3=0.d0
            plumi=1.d0

            if(theta > 0.d0) then
                plumi=-1.d0
            end if
                
            cons2=0.5d0*(root3+plumi*cons1*root3)
        end if
        
        if(abthe < 29.d0) then
            cons2=costh*((1.d0+tanth*tant3)+cons1*(tant3-tanth)*root3)
            cons3=(root3*sinth+3.d0*cons1*costh)/(2.d0*varj2*cost3)
        end if

    case(4)     ! ncrit=4: Drucker-Prager
        snphi=dsin(frict*degres)
        cons1=2.d0*snphi/(root3*(3.d0-snphi))
        cons2=1.d0
        cons3=0.d0

    case(5)     ! ncrit=5: Cam Clay
!         abthe=dabs(theta*radian)
        
!         if(abthe >= 29.d0) then
!             gseta=2.d0*root3*snphi/(3.d0+2.d0*snphi)
!             cons1=(1.d0/3.d0)*(1.d0-(varj2/((smean*gseta)**2.d0)))/smean
!             cons2=2.d0*steff/(smean**2.d0*(gseta)**2.d0)
!             cons3=0.d0
!         end if
        
!         if(abthe < 29.d0) then  
!             cons1=(1.d0/3.d0)*(1-(varj2/(smean*csl)**2.d0))/smean
!             cons2=(2.d0*steff/(smean*csl)**2)-tant3*((2.d0*varj2*(root13*costh*snphi-sinth))/(smean**2.d0*csl*snphi*steff))
!             cons3=-1.d0*(costh*snphi-snphi)/(cost3*steff*smean**2.d0*csl*snphi)
!         end if
        cons1=(1.d0/9.d0)*(smean-3*yield
end select


! *** Version Elkassas
!      change 45   eq(3.28) df/dsigma
!    6 do 60 istr1=1,nstr1
!   60 avect(istr1)=veca1(istr1)*csl**2*(2*smean+ck*suctot-pnotlc(kgaus))/3.+3*devia(istr1)

!     dfs= df/ds                               eq(3.31)
!   dfs=-1.*csl**2*(ck*(pnotlc(kgaus)-smean)+((smean+ck*suctot)*beta*(alandas-rlimit*alanda0)*pnotlc(kgaus)*alog(abs(pnotlc(kgaus)/pc)))/(alandas-akee))

!      goto 100
!      end of change 45
! *** FIN Version Elkassas

do istr1=1,nstr1
    avect(istr1)=cons1*veca1(istr1)+cons2*veca2(istr1)+cons3*veca3(istr1)
end do

return
end


! *********************************************************************
!   Subroutine flowpl - Owen p.243 
!   This subroutine evaluates the plastic d vector.
! ***********************************************************************


subroutine flowpl(lprop)

use variables

implicit none

integer :: istr1, lprop
!double precision :: root3=1.73205080757
double precision :: denom, fmul1, fmul2, fmul3, hards


!! *** Version Elkassas
!! Add the calculation for the reduced suction the prameters landas and so on
!  !     change 17                   aks           swelling index        eq(2.73)
!      aks=props(lprop,19)
!!     end of change 17

! !     change  39                  ck           parameter which control the increase of cohesion with suction
!      ck=props(lprop,21)
!!     end of change 39

! !  ckm=props(lprop,48)


! !      alandas           alanda at a certain suction      eq(2.67)
!      alandas=alanda0*((1.-rlimit)*exp(-1.*beta*suctot)+rlimit)


! !  gs   eq(4.5)            intersection og virgin cosolidation line with the specific volume axis at certain suction

!      gs=rnot+(alanda0-akee)*alog(2.)-aks*alog(abs((suctot+patms)/patms)
!     1 )-(alanda0-alandas)*alog(abs(pc))


!  ! change  20          specv             specific volume         eq(4.2)
!      specv=gs-(alandas-akee)*alog(abs(pnotlc(kgaus)))-
!     1 akee*alog(abs(smean))
!!     end of change 20

!      goto 20
!!   if(iincs == 1.and.iiter == 1.and.istep == 1)
!      p=smean

!!      anyo=ann-alanda*alog(abs(p))
!      k=specv*p/akee
!      poiss=props(lprop,2)

!      young=abs(k*3.*(1.-2.*poiss))
!      goto 30

!! *** FIN Version Elkassas

young=props(lprop,1)
poiss=props(lprop,2)
hards=props(lprop,6)
fmul1=young/(1.d0+poiss)

! print *,'dans flowpl'
! print *,'ntype=',ntype
! print *,"young=",young
! print *,'poisson=',poiss
! print *,'hards=',hards
! print *,'avect=',avect

if (ntype == 2 .or. ntype == 3) then
    !Plane strain: ntype = 2 / Axial symmetry: ntype = 3
    fmul2=young*poiss*(avect(1)+avect(2)+avect(4))/((1.d0+poiss)*(1.d0-2.d0*poiss))
    dvect(1)=fmul1*avect(1)+fmul2
    dvect(2)=fmul1*avect(2)+fmul2
    dvect(3)=0.5d0*avect(3)*young/(1.d0+poiss)
    dvect(4)=fmul1*avect(4)+fmul2
else
    !Plane stress: ntype = 1
    fmul3=young*poiss*(avect(1)+avect(2))/(1.d0-poiss*poiss)
    dvect(1)=fmul1*avect(1)+fmul3
    dvect(2)=fmul1*avect(2)+fmul3
    dvect(3)=0.5d0*avect(3)*young/(1.d0+poiss)
    dvect(4)=fmul1*avect(4)+fmul3
end if

! print *,'M1=',fmul2
! print *,'dvect=',dvect

! Compute 1/(H'+dvect*avect) for later evaluation of the elasto-plastic matrix Dep
! /!\ matrix D is constant in this version, ie not re-evaluated even if yield occured
70 denom=hards

do istr1=1,nstr1
    denom=denom+avect(istr1)*dvect(istr1)
end do

abeta=1.d0/denom


return
end

